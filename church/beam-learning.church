;; (define (program-compression data)
;;   (let* ([all-examples (map tree->program data)]
;;          [prog (program->sexpr (beam-score-compression data (list 'uniform-draw (pair 'list all-examples)) 1))])
;;     (pretty-print (list "compressed-program:" prog "size: " (size prog)))
;;     (lambda () (eval prog))))

;;;searches through compressions of the sexpr (uniform-draw (list [observed data here])) , returns a thunk evaluates a uniforml draws over compressed forms of each observation
(define (learn-model data)
  (let* ([initial-sexpr (make-initial-sexpr data)]
         [learned-sexpr (beam-learn data initial-sexpr)]
         [model (lambda () (lazy-list->all-list (eval learned-sexpr)))])
    (pretty-print (list "compressed-program:" learned-sexpr "size: " (size learned-sexpr)))    
    model))

;;;turns each of the examples into a program then wraps that in a uniform draw
(define (make-initial-sexpr data)
  (let* ([literal-sexprs (map tree->program data)])
    (list 'uniform-draw (pair 'list literal-sexprs))))
         
(define (beam-learn data sexpr)
  sexpr)

;; (define (beam-learn-draft data sexpr beam-size)
;;            (for-each display (list "original expr:\n" sexpr "\n"
;;                                    "size: " (size sexpr)
;;                                    "\n\n"
;;                                    "compressing...\n"))
;;            (first (sort-by-size
;;             (unique-programs
;;              (beam-learn-search-compressions data beam-size (make-program '() sexpr))))))


;; (define (beam-learn-search-compressions data beam-size program)
;;   (iterated-compressions (lambda (progs) (best-n beam-size (unique-programs progs))) program))

;; (define (best-n n programs)
;;   (max-take (sort-by-score-and-size programs) n))



(define (sort-by-score-and-size programs data)
  (let* ([program-sizes (map (compose size program->sexpr) programs)]
         [program-scores (make-list (length programs) 0)]
         ;[program-scores (map (compose (lambda (prog) (scoring data prog 10)) program->sexpr) programs)]
         [total-weight (combine-size-score program-sizes program-scores)]
         [db (pretty-print (zip programs program-sizes program-scores))]
         [programs-with-weights (zip programs total-weight)]
         [weight< (lambda (a b) (< (second a) (second b)))])
    (map first (list-sort weight< programs-with-weights))))

(define (combine-size-score sizes scores)
  (map + sizes scores))

(define (compose f g)
  (lambda (x) (f (g x))))

(define scoring  
  (lambda (data prog popsize) ;;scorer
    (let* ((samples (smc-core (map list (iota (+ 1 (lazy-list-size  data)))) popsize 0
                                   (lambda (depth) (lambda () (let ((s (eval prog)))
                                                                (pair (lazy-equal? s data depth)
                                                                      (lambda () (first (lazy-list->list s depth)))))))))
                ;;remove duplicates in order to do selective model averaging:
                (samples (fold (lambda (s a) (if (member (mcmc-state->addrval s) (map mcmc-state->addrval a)) a (pair s a))) '() samples))
                (scores (map mcmc-state->score samples))
                (score (if (null? scores)
                           -inf.0
                           (apply log-sum-exp scores))))
           score)))


;;;GRAMMAR
(define MAX-FUNCS 1)
(define MAX-ARITY 1)

(define (gen-program)
  (let* ([num-of-funcs (sample-integer MAX-FUNCS)]
         ;;[db (pretty-print "in nfqp")]
         [function-signatures (gen-func-signatures num-of-funcs)]
         [functions (gen-functions  function-signatures)]
         [body (gen-expr '() function-signatures)]
         [reset-symbols (reset-symbol-indizes!)])
    (combine-program-parts functions body)))
(define (combine-program-parts functions body)
  (lazy-append (lazy-append (lazy-list 'let '()) functions) (lazy-list body)))

;;function signature related functions
(define get-name lazy-first)
(define get-vars lazy-rest)
(define (get-arity signature)
  (lazy-length (get-vars signature)))

(define (gen-func-signatures num-of-funcs)
  (if (= num-of-funcs 0)
      '()
      (lazy-pair (gen-func-signature) (gen-func-signatures (- num-of-funcs 1)))))
;;      (lazy-repeat num-of-funcs gen-func-signature))

(define (gen-func-signature)
  (let* ([name (sym 'F)]
         ;;[name 'F]
         [arity (sample-integer MAX-ARITY)]
         [vars (gen-vars arity)])
    (combine-sig-parts name vars)))
(define combine-sig-parts lazy-pair)

(define (gen-vars arity)
  (if (= 0 arity)
      '()
      (lazy-pair (sym 'V) (gen-vars (- arity 1)))))
;;  (lazy-repeat arity (lambda () (sym 'V))))


(define (gen-functions function-signatures)
  (if (lazy-null? function-signatures)
      '()
      (lazy-pair (gen-function (lazy-first function-signatures) function-signatures) (gen-functions (lazy-rest function-signatures)))))

;;creates a function based on function-signature and may use functions specified by function-signatures in the body
(define (gen-function function-signature function-signatures)
  (let* ([function-signatures (lazy-remove function-signature function-signatures)] ;;ensures no recursive functions
         [vars (get-vars function-signature)]
         [body (gen-expr vars function-signatures)])
    (combine-function-parts function-signature body)))
(define (combine-function-parts function-signature body)
  (lazy-list 'define (get-name function-signature) (lazy-list 'lambda (get-vars function-signature) body)))

(define (gen-expr vars function-signatures)
  (cond [(and (null? vars) (null? function-signatures))
         (sample (multinomial (list (lambda () (gen-if vars function-signatures)) gen-bool) (list 1/4 3/4)))]
        [(null? vars)
         (sample (multinomial (list (lambda () (gen-if vars function-signatures)) gen-bool (lambda () (gen-application vars function-signatures))) (list 1/8 3/4 1/8)))]
        [(null? function-signatures)
         (sample (multinomial (list (lambda () (gen-if vars function-signatures)) gen-bool (lambda () (choose-var vars))) (list 1/8 3/4 1/8)))]         
        [else
         (sample (multinomial (list (lambda () (gen-if vars function-signatures)) gen-bool (lambda () (gen-application vars function-signatures)) (lambda () (choose-var vars))) (list 1/12 3/4 1/12 1/12)))]))

(define (gen-bool)
  (uniform-draw '(#t #f)))

(define (gen-if vars function-signatures)
  (combine-if-parts 'if (gen-expr vars function-signatures) (gen-expr vars function-signatures) (gen-expr vars function-signatures)))

(define combine-if-parts lazy-list)

(define (gen-application vars function-signatures)
  (let* (;;[db (pretty-print "in gen-app")]
         [function-signature (lazy-uniform-draw function-signatures)]
         [function (get-name function-signature)]
         [arity (get-arity function-signature)]
         [args (gen-args arity vars function-signatures)])
    (combine-application-parts function args)))
(define combine-application-parts lazy-pair)

(define (gen-args arity vars function-signatures)
  (if (= arity 0)
      '()
      (lazy-pair (gen-expr vars function-signatures) (gen-args (- arity 1) vars function-signatures))))
;;  (lazy-repeat arity (lambda () (gen-expr vars function-signatures))))

(define choose-var lazy-uniform-draw)

(define (lazy-uniform-draw ll)
  (let* ([unlazy-list (lazy-list->all-list ll)]
         [chosen (safe-uniform-draw unlazy-list)])
    (list->lazy-list chosen)))
         

;;;INFERENCE
;;(define lett (list->lazy-list '(lambda () t)))
;;(pretty-print (map (lambda (x) (lazy-list->list lett x)) (range 0 10)))




;;;TESTS
;;;grammar test
;;;evaluation check
;; (define testp (lazy-list->all-list (gen-program)))
;; (pretty-print (list testp (eval testp)))

;;;scorer tests
;;(define scorer (make-scorer gen-program))
;;;expression with functions that have variables (not used in body)
;;(pretty-print (exp (scorer '() '(lambda () (define F1 (lambda (V1 V2) t)) (define F2 (lambda (V3) t)) (if t f t)))))
;;;expression with functions used in body
;;(pretty-print (exp (scorer '() '(lambda () (define F1 (lambda (V1 V2) t)) (define F2 (lambda (V3) t)) (if (F1 t f) f t)))))
;;;expression with functions used in body and variables
;;(pretty-print (exp (scorer '() '(lambda () (define F1 (lambda (V1 V2) t)) (define F2 (lambda (V3) V3)) (if (F1 t f) f t)))))

;;(pretty-print (exp (scorer '() '(lambda () (define F1 (lambda (V1 V2) (F2 V1))) (define F2 (lambda (V3) V3)) (if (F1 t f) f t)))))
;;;proposer tests
;;(+ 2 2)
;; (define t #t)
;; (define f #f)

;;(define test-expr (lambda () '(lambda () (if (if t t t) (if t t t) (if t t t)))))

;; (define proposer (make-proposer scorer))

;; (pretty-print proposer)
;; (define init-state (make-initial-mcmc-state))
;; (define test-state (list (first init-state) (pair 't test-expr) (third init-state)))

;; (pretty-print (mcmc-state->query-value test-state))
;; (exp (scorer '() (mcmc-state->query-value test-state)))

;; (proposer test-state)
;;;grammar-xrp tests
;;(lazy-list->all-list ((grammar-xrp gen-program)))


;(pretty-print (xrp-draw-name gxrp))
;;;mh test using grammar-xrp
;; (define t #t)
;; (define f #f)
;;;depth test
;; (mh-query
;;  10 1
;;  (define lazy-program ((grammar-xrp gen-program)))
;;  (define program (lazy-list->all-list lazy-program))
;;  program
;;  (equal? (depth program) 1))
;;;eval test
;; (mh-query
;;  10 1
;;  (define lazy-program ((grammar-xrp gen-program)))
;;  (define program (lazy-list->all-list lazy-program))
;;  program
;;  (equal? (eval program) #t))

;;;abstraction-proposer
(define (make-abstraction-proposer grammar)
  (lambda (state address value)
    (let* (;;;(de)compress the program
           [program (mcmc-state->query-value state)]
           [ret1 (abstraction-move program)]
           [new-program (first ret1)]
           [lazy-new-program (list->lazy-list new-program)]
           [db (pretty-print (list "new program" new-program))]
           [abstraction-fw-prob (second ret1)]
           [abstraction-bw-prob (third ret1)]
         ;;;make nfqp out of the with-procedure proc
           [temps-nfqp (make-temps-nfqp lazy-new-program grammar)]
           [depths (map list (iota (compute-depth lazy-new-program)))]
           ;;[db (pretty-print (list "entering the core" address))]
           [db (pretty-print (list "entering the core uncompressed-state xrps" address (map xrp-draw-ticks (map rest (mcmc-state->xrp-draws state)))))]
;;           [states (smc-core depths 1 10 temps-nfqp address)]
           [states (smc-core depths 1 10 temps-nfqp '())]
         ;;;get the xrps and return them as interventions
           ;;[db (pretty-print (list "exiting the core" address))]
           [db (pretty-print (list "exiting the core uncompressed-state xrps" (map xrp-draw-ticks (map rest (mcmc-state->xrp-draws state)))))]
           [xrp-draws (map rest (mcmc-state->xrp-draws (first states)))] ;;;choosing the first state is arbitrary, should all be same

           [interventions (map (make-interventions address (get-xrp-ticks state)) xrp-draws)]
;;           [interventions (map (lambda (xrp-draw) (pair xrp-draw (xrp-draw-value xrp-draw))) xrp-draws)]
           [db (pretty-print (list "interventions" interventions))])
      (list abstraction-fw-prob abstraction-bw-prob interventions))))

;;;remove extra address made by call to nfqp thunk then return a p modified draw with the value as an intervention
(define (make-interventions init-address state-xrp-ticks)
  (lambda (xrp-draw)
    (let* ([address (xrp-draw-address xrp-draw)]
           [new-address (adjust-address address init-address)]
           [new-xrp-draw (make-xrp-draw new-address
                                        (xrp-draw-value xrp-draw)
                                        (xrp-draw-name xrp-draw)
                                        (xrp-draw-proposer xrp-draw)
                                        state-xrp-ticks
                                        (xrp-draw-score xrp-draw)
                                        (xrp-draw-support xrp-draw))])
      (pair new-xrp-draw (xrp-draw-value xrp-draw)))))

(define (get-xrp-ticks mcmc-state)
  (let* ([draws-addbox (mcmc-state->xrp-draws mcmc-state)]
         [xrp-draw (rest (first draws-addbox))])
    (xrp-draw-ticks xrp-draw)))
   
(define (adjust-address address init-address)
  (append (drop-right address 1) init-address))

         
                                      
    
    

   
;;      [db (pretty-print (list "scoring new program" new-program))]
    ;;      [new-program-score (scorer '() new-program)]
    ;;      [db (pretty-print (list "scoring old program" new-program))]
    ;;      [old-program-score (scorer '() program)])
    ;; (list new-program (+ abstraction-fw-prob new-program-score) (+ abstraction-bw-prob old-program-score)))) 
         

;; (mh-query
;;  10 20
;;  (define lazy-grammar gen-program)
;;  (define lazy-program (lazy-grammar))
;;  (define program (lazy-list->all-list lazy-program))
;;  program
;;  (equal? (eval program) #t))

(mh-query
 10 20
 (define lazy-program ((with-proposer gen-program (make-abstraction-proposer gen-program))))

 (define program (lazy-list->all-list lazy-program))
 program
 (equal? (eval program) #t))


;; (mh-query
;;  10 20
;;  (define lazy-grammar (with-proposer gen-program (make-abstraction-proposer gen-program)))
;;  (define lazy-program (lazy-grammar))
;;  (define program (lazy-list->all-list lazy-program))
;;  program
;;  (equal? (eval program) #t))

;;(repeat 20 f)
;;(define testp (gen-program))
;;(pretty-print (map (lambda (x) (lazy-list->list testp x)) (range 0 (compute-depth testp))))
;; (define testq (list->lazy-list '(lambda () (define F (lambda () t)) (if t f t))))
;;  (pretty-print (map (lambda (x) (lazy-list->list testq x)) (range 0 (compute-depth testq))))

;;(define proposer (make-proposer scorer))



;; (proposer 
;;(scorer '() (lazy-list 'if 't 'f 't))


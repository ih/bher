(define (prototype) (node 'a (node 'b (node 'a (node 'b) (node 'b)))))

(define (two-node) (node 'a (node 'b)))

(define (gen-data model amount)
  (delete '() (repeat amount model)))

(define prototype-data (map lazy-list->all-list (gen-data prototype 5)))


;;;learn-model tests
;; (member?-test "make-initial-sexpr evaluation" (lazy-list->all-list (eval (make-initial-sexpr (list '(a) '(a (b)))))) (list '(a) '(a (b))))

;; (member?-test "learned-model" (lazy-list->all-list ((learn-model '((a) (a (b)))))) '((a) (a (b))))


;;;sort-by-size-and-score related
(define simplest-data (lazy-list 'a))
(define possible-program-sexprs  (list '(uniform-draw (list (node 'a))) '(uniform-draw (list (node 'b))) '(uniform-draw (list (node 'a (node 'b))))))
(define possible-programs (map (lambda (prog) (make-program '() prog)) possible-program-sexprs))

;;;scoring tests just to see if it runs
;; (evaluates?-test "score a single node program" (scoring '(node 'b) 10) simplest-data )
;; (evaluates?-test "score a list of programs" (map (lambda (prog) (scoring prog simplest-data 10)) possible-program-sexprs))

;;;list-sorting tests 
;;partition test
;; (define test-list '(1 2 3 5 6 7))
;; (equal?-test "split with 4" (my-partition < 4 test-list) '((1 2 3) (5 6 7)))
;; ;;my-list-sort test
;; (equal?-test "sorting test" (my-list-sort > test-list) (reverse test-list))
;;;combine-size-score test
(define sizes '(1 2 3))
(define scores '(-10 -20 -30))

(equal?-test "combine-size-score test" (combine-size-score sizes scores 1 .1) '(2.0 4.0 6.0))
;;;sort-by-score-and-size tests
;;test where growth noise is higher than label noise
(define timed-sort-by-score-and-size (time-it sort-by-score-and-size "sort-by-score-and-size"))

;; (equal?-test "sort-by-score-and-size simplest data, based on score only" (sort-by-score-and-size possible-programs simplest-data 0 1) (map (lambda (prog) (make-program '() prog)) (list '(uniform-draw (list (node 'a))) '(uniform-draw (list (node 'a (node 'b)))) '(uniform-draw (list (node 'b))))))

;; (equal?-test "sort-by-score-and-size simplest data, based on weight only" (timed-sort-by-score-and-size possible-programs simplest-data 1 0) (map (lambda (prog) (make-program '() prog)) (list '(uniform-draw (list (node 'a))) '(uniform-draw (list (node 'b))) '(uniform-draw (list (node 'a (node 'b)))))))

;;;best-n tests
(define timed-best-n (time-it best-n "best-n"))
(equal?-test "best-n by score only" (timed-best-n 2 possible-programs simplest-data 0 1) (map (lambda (prog) (make-program '() prog)) (list '(uniform-draw (list (node 'a))) '(uniform-draw (list (node 'a (node 'b)))))))








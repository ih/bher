;;;GRAMMAR
(define MAX-FUNCS 4)
(define MAX-ARITY 4)

(define (gen-program)
  (let* ([num-of-funcs (sample-integer MAX-FUNCS)]
         ;;[db (pretty-print "in nfqp")]
         [function-signatures (gen-func-signatures num-of-funcs)]
         [functions (gen-functions  function-signatures)]
         [body (gen-expr '() function-signatures)]
         [reset-symbols (reset-symbol-indizes!)])
    (combine-program-parts functions body)))
(define (combine-program-parts functions body)

  (lazy-append (lazy-append (lazy-list 'lambda '()) functions) (lazy-list body)))

;;function signature related functions
(define get-name lazy-first)
(define get-vars lazy-rest)
(define (get-arity signature)
  (lazy-length (get-vars signature)))

(define (gen-func-signatures num-of-funcs)
  (if (= num-of-funcs 0)
      '()
      (lazy-pair (gen-func-signature) (gen-func-signatures (- num-of-funcs 1)))))
;;      (lazy-repeat num-of-funcs gen-func-signature))

(define (gen-func-signature)
  (let* ([name (sym 'F)]
         ;;[name 'F]
         [arity (sample-integer MAX-ARITY)]
         [vars (gen-vars arity)])
    (combine-sig-parts name vars)))
(define combine-sig-parts lazy-pair)

(define (gen-vars arity)
  (if (= 0 arity)
      '()
      (lazy-pair (sym 'V) (gen-vars (- arity 1)))))
;;  (lazy-repeat arity (lambda () (sym 'V))))


(define (gen-functions function-signatures)
  (if (lazy-null? function-signatures)
      '()
      (lazy-pair (gen-function (lazy-first function-signatures) function-signatures) (gen-functions (lazy-rest function-signatures)))))

;;creates a function based on function-signature and may use functions specified by function-signatures in the body
(define (gen-function function-signature function-signatures)
  (let* ([function-signatures (lazy-remove function-signature function-signatures)] ;;ensures no recursive functions
         [vars (get-vars function-signature)]
         [body (gen-expr vars function-signatures)])
    (combine-function-parts function-signature body)))
(define (combine-function-parts function-signature body)
  (lazy-list 'define (get-name function-signature) (lazy-list 'lambda (get-vars function-signature) body)))

(define (gen-expr vars function-signatures)
  (cond [(and (null? vars) (null? function-signatures))
         (sample (multinomial (list (lambda () (gen-if vars function-signatures)) gen-bool) (list 1/4 3/4)))]
        [(null? vars)
         (sample (multinomial (list (lambda () (gen-if vars function-signatures)) gen-bool (lambda () (gen-application vars function-signatures))) (list 1/8 3/4 1/8)))]
        [(null? function-signatures)
         (sample (multinomial (list (lambda () (gen-if vars function-signatures)) gen-bool (lambda () (choose-var vars))) (list 1/8 3/4 1/8)))]         
        [else
         (sample (multinomial (list (lambda () (gen-if vars function-signatures)) gen-bool (lambda () (gen-application vars function-signatures)) (lambda () (choose-var vars))) (list 1/12 3/4 1/12 1/12)))]))

(define (gen-bool)
  (uniform-draw '(t f)))

(define (gen-if vars function-signatures)
  (combine-if-parts 'if (gen-expr vars function-signatures) (gen-expr vars function-signatures) (gen-expr vars function-signatures)))

(define combine-if-parts lazy-list)

(define (gen-application vars function-signatures)
  (let* (;;[db (pretty-print "in gen-app")]
         [function-signature (lazy-uniform-draw function-signatures)]
         [function (get-name function-signature)]
         [arity (get-arity function-signature)]
         [args (gen-args arity vars function-signatures)])
    (combine-application-parts function args)))
(define combine-application-parts lazy-pair)

(define (gen-args arity vars function-signatures)
  (if (= arity 0)
      '()
      (lazy-pair (gen-expr vars function-signatures) (gen-args (- arity 1) vars function-signatures))))
;;  (lazy-repeat arity (lambda () (gen-expr vars function-signatures))))

(define choose-var lazy-uniform-draw)

(define (lazy-uniform-draw ll)
  (let* ([unlazy-list (lazy-list->all-list ll)]
         [chosen (safe-uniform-draw unlazy-list)])
    (list->lazy-list chosen)))
         

;;;INFERENCE
;;(define lett (list->lazy-list '(lambda () t)))
;;(pretty-print (map (lambda (x) (lazy-list->list lett x)) (range 0 10)))




;;;TESTS
;;;grammar test
;;;evaluation check
;;(define testp (lazy-list->all-list (gen-program)))
;;(pretty-print (list testp (eval testp)))

;;;scorer tests
(define scorer (make-scorer gen-program))
;;;expression with functions that have variables (not used in body)
(pretty-print (exp (scorer '() '(lambda () (define F1 (lambda (V1 V2) t)) (define F2 (lambda (V3) t)) (if t f t)))))
;;;expression with functions used in body
;;(pretty-print (exp (scorer '() '(lambda () (define F1 (lambda (V1 V2) t)) (define F2 (lambda (V3) t)) (if (F1 t f) f t)))))
;;;expression with functions used in body and variables
;;(pretty-print (exp (scorer '() '(lambda () (define F1 (lambda (V1 V2) t)) (define F2 (lambda (V3) V3)) (if (F1 t f) f t)))))

;;(pretty-print (exp (scorer '() '(lambda () (define F1 (lambda (V1 V2) (F2 V1))) (define F2 (lambda (V3) V3)) (if (F1 t f) f t)))))
;;;proposer tests
;;(+ 2 2)
;; (define t #t)
;; (define f #f)

;; (define test-expr (lambda () '(lambda () (if (if t t t) (if t t t) (if t t t)))))

;; (define proposer (make-proposer scorer))

;; (pretty-print proposer)
;; (define init-state (make-initial-mcmc-state))
;; (define test-state (list (first init-state) (pair 't test-expr) (third init-state)))

;; (pretty-print (mcmc-state->query-value test-state))
;; (exp (scorer '() (mcmc-state->query-value test-state)))

;; (proposer test-state)
;;;grammar-xrp tests
;;(lazy-list->all-list ((grammar-xrp gen-program)))
;;;mh test using grammar-xrp

;;(define testp (gen-program))
;;(pretty-print (map (lambda (x) (lazy-list->list testp x)) (range 0 (compute-depth testp))))
;; (define testq (list->lazy-list '(lambda () (define F (lambda () t)) (if t f t))))
;;  (pretty-print (map (lambda (x) (lazy-list->list testq x)) (range 0 (compute-depth testq))))

;;(define proposer (make-proposer scorer))



;; (proposer 
;;(scorer '() (lazy-list 'if 't 'f 't))


;;;GRAMMAR
(define MAX-FUNCS 5)
(define MAX-ARITY 3)


(define (gen-program)
  (let* ([num-of-funcs (random-integer MAX-FUNCS)]
         [db (pretty-print "in nfqp")]
         [function-signatures (gen-func-signatures num-of-funcs)]
         [functions (gen-functions  function-signatures)]
         [body (gen-expr '() function-signatures)])
    (combine-program-parts functions body)))
(define (combine-program-parts functions body)
  (lazy-append (lazy-append (lazy-list 'let '()) functions) (lazy-list body)))

;;function signature related functions
(define get-name lazy-first)
(define get-vars lazy-rest)
(define (get-arity signature)
  (lazy-length (get-vars signature)))

(define (gen-func-signatures num-of-funcs)
  (if (= num-of-funcs 0)
      '()
      (lazy-pair (gen-func-signature) (gen-func-signatures (- num-of-funcs 1)))))
;;      (lazy-repeat num-of-funcs gen-func-signature))

(define (gen-func-signature)
  (let* ([name (sym 'F)]
         [arity (random-integer MAX-ARITY)]
         [vars (gen-vars arity)])
    (combine-sig-parts name vars)))
(define combine-sig-parts lazy-pair)

(define (gen-vars arity)
  (if (= 0 arity)
      '()
      (lazy-pair (sym 'V) (gen-vars (- arity 1)))))
;;  (lazy-repeat arity (lambda () (sym 'V))))


(define (gen-functions function-signatures)
  (if (lazy-null? function-signatures)
      '()
      (lazy-pair (gen-function (lazy-first function-signatures) function-signatures) (gen-functions (lazy-rest function-signatures)))))

;;creates a function based on function-signature and may use functions specified by function-signatures in the body
(define (gen-function function-signature function-signatures)
  (let* ([function-signatures (lazy-remove function-signature function-signatures)] ;;ensures no recursive functions
         [vars (get-vars function-signature)]
         [body (gen-expr vars function-signatures)])
    (combine-function-parts function-signature body)))
(define (combine-function-parts function-signature body)
  (lazy-list 'define function-signature body))

(define (gen-expr vars function-signatures)
  (cond [(and (null? vars) (null? function-signatures))
         (sample (multinomial (list (lambda () (gen-if vars function-signatures)) gen-bool) (list 1/4 3/4)))]
        [(null? vars)
         (sample (multinomial (list (lambda () (gen-if vars function-signatures)) gen-bool (lambda () (gen-application vars function-signatures))) (list 1/8 3/4 1/8)))]
        [(null? function-signatures)
         (sample (multinomial (list (lambda () (gen-if vars function-signatures)) gen-bool (lambda () (choose-var vars))) (list 1/8 3/4 1/8)))]         
        [else
         (sample (multinomial (list (lambda () (gen-if vars function-signatures)) gen-bool (lambda () (gen-application vars function-signatures)) (lambda () (choose-var vars))) (list 1/12 3/4 1/12 1/12)))]))

(define (gen-bool)
  (uniform-draw '(t f)))

(define (gen-if vars function-signatures)
  (combine-if-parts 'if (gen-expr vars function-signatures) (gen-expr vars function-signatures) (gen-expr vars function-signatures)))

(define combine-if-parts lazy-list)

(define (gen-application vars function-signatures)
  (let* ([function-signature (lazy-uniform-draw function-signatures)]
         [function (get-name function-signature)]
         [arity (get-arity function-signature)]
         [args (gen-args arity vars function-signatures)])
    (combine-application-parts function args)))
(define combine-application-parts lazy-pair)

(define (gen-args arity vars function-signatures)
  (if (= arity 0)
      '()
      (lazy-pair (gen-expr vars function-signatures) (gen-args (- arity 1) vars function-signatures))))
;;  (lazy-repeat arity (lambda () (gen-expr vars function-signatures))))

(define choose-var lazy-uniform-draw)

;;(pretty-print (iota 2))
;;(lazy-equal? (lazy-list 'a (lazy-list 'b 'd) 'c) (list->lazy-list '(a (b d) c)) 10)

;;;INFERENCE
(define scorer (make-scorer gen-program))
(exp (scorer '() '(let () t)))

;;;TESTS


;;(define proposer (make-proposer scorer))


;; (define init-state (make-initial-mcmc-state))
;; (define test-state (list (first init-state) (pair 't (lambda () '(if t (if f f f) t))) (third init-state)))

;; (pretty-print (mcmc-state->query-value test-state))
;; (exp (scorer '() (mcmc-state->query-value test-state)))

;; (proposer test-state)

;; (proposer 
;;(scorer '() (lazy-list 'if 't 'f 't))

